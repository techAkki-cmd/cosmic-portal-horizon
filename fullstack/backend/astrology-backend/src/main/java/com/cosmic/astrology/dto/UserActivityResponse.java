package com.cosmic.astrology.dto;

import com.fasterxml.jackson.annotation.JsonFormat;
import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import io.swagger.v3.oas.annotations.media.Schema;
import jakarta.validation.constraints.*;

import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.time.temporal.ChronoUnit;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.stream.Collectors;

/**
 * Complete User Activity Response DTO for Vedic Astrology Application
 * Contains comprehensive user activity history, engagement analytics, and cosmic insights
 */
@JsonInclude(JsonInclude.Include.NON_NULL)
@JsonIgnoreProperties(ignoreUnknown = true)
@Schema(description = "Comprehensive user activity history with engagement analytics and cosmic insights")
public class UserActivityResponse {
    
    // ================ PAGINATION FIELDS ================
    
    @Min(value = 0, message = "Total activities cannot be negative")
    @Schema(description = "Total number of activity records", example = "25", minimum = "0")
    private Integer totalActivities;
    
    @Min(value = 0, message = "Current page cannot be negative")
    @Schema(description = "Current page number (0-based)", example = "0", minimum = "0")
    private Integer currentPage;
    
    @Min(value = 1, message = "Page size must be at least 1")
    @Max(value = 100, message = "Page size cannot exceed 100")
    @Schema(description = "Number of items per page", example = "20", minimum = "1", maximum = "100")
    private Integer pageSize;
    
    @Min(value = 0, message = "Total pages cannot be negative")
    @Schema(description = "Total number of pages", example = "2", minimum = "0")
    private Integer totalPages;
    
    // ================ ACTIVITY DATA FIELDS ================
    
    @Schema(description = "List of user activities with detailed information")
    private List<ActivityRecord> activities;
    
    @JsonFormat(pattern = "yyyy-MM-dd'T'HH:mm:ss")
    @Schema(description = "When this activity data was retrieved", example = "2024-01-15T08:30:00")
    private LocalDateTime retrievedAt;
    
    @Schema(description = "Comprehensive activity summary and analytics")
    private ActivitySummary summary;
    
    @Schema(description = "Recent activity records for quick access")
    private List<ActivityRecord> recentActivities;
    
    @Min(value = 0, message = "Activity count cannot be negative")
    @Schema(description = "Count of recent activities", example = "8", minimum = "0")
    private Integer activityCount;
    
    // ================ USER CONTEXT FIELDS ================
    
    @Size(max = 50, message = "Username cannot exceed 50 characters")
    @Schema(description = "Username of the user", example = "cosmic_seeker")
    private String username;
    
    @Min(value = 0, message = "Total logins cannot be negative")
    @Schema(description = "Total number of user logins", example = "142", minimum = "0")
    private Integer totalLogins;
    
    @Min(value = 0, message = "Login streak cannot be negative")
    @Schema(description = "Current consecutive login streak in days", example = "7", minimum = "0")
    private Integer loginStreak;
    
    @JsonFormat(pattern = "yyyy-MM-dd'T'HH:mm:ss")
    @Schema(description = "Last login timestamp", example = "2024-01-14T16:45:00")
    private LocalDateTime lastLogin;
    
    @JsonFormat(pattern = "yyyy-MM-dd'T'HH:mm:ss")
    @Schema(description = "Last active date", example = "2024-01-14T18:30:00")
    private LocalDateTime lastActiveDate;
    
    @Schema(description = "IP address of last login", example = "192.168.1.100")
    private String lastLoginIp;
    
    @Min(value = 0, message = "Charts generated cannot be negative")
    @Schema(description = "Total number of charts generated by user", example = "15", minimum = "0")
    private Integer chartsGenerated;
    
    @JsonFormat(pattern = "yyyy-MM-dd'T'HH:mm:ss")
    @Schema(description = "User registration date", example = "2023-06-15T10:30:00")
    private LocalDateTime memberSince;
    
    @Size(max = 100, message = "Display name cannot exceed 100 characters")
    @Schema(description = "User's display name", example = "Cosmic Seeker")
    private String displayName;
    
    @Size(max = 100, message = "Email cannot exceed 100 characters")
    @Schema(description = "User's email address", example = "user@example.com")
    private String email;
    
    @Schema(description = "User's current status", 
            allowableValues = {"ACTIVE", "INACTIVE", "SUSPENDED", "PENDING"},
            example = "ACTIVE")
    private String userStatus;
    
    @Schema(description = "User's subscription type", 
            allowableValues = {"FREE", "BASIC", "PREMIUM", "PROFESSIONAL"},
            example = "PREMIUM")
    private String subscriptionType;
    
    @Schema(description = "User's timezone", example = "Asia/Kolkata")
    private String timezone;
    
    @Schema(description = "User's preferred language", example = "en")
    private String preferredLanguage;
    
    // ================ ENHANCED ANALYTICS FIELDS ================
    
    @Schema(description = "Activity filtering criteria applied")
    private ActivityFilter appliedFilter;
    
    @Schema(description = "Activity trends and patterns")
    private ActivityTrends trends;
    
    @Schema(description = "Data quality and reliability metrics")
    private DataQuality dataQuality;
    
    @Schema(description = "Activity categorization breakdown")
    private Map<String, Integer> activityCategorization;
    
    @Schema(description = "Time-based activity distribution")
    private Map<String, Integer> timeDistribution;
    
    @Schema(description = "Device and platform analytics")
    private Map<String, Integer> deviceAnalytics;
    
    @Schema(description = "Geographic activity distribution")
    private Map<String, Integer> geographicDistribution;
    
    // ================ NESTED CLASSES ================
    
    @Schema(description = "Individual activity record with enhanced tracking")
    public static class ActivityRecord {
        @Schema(description = "Unique activity identifier", example = "1")
        private Long id;
        
        @NotBlank(message = "Activity type cannot be blank")
        @Size(max = 50, message = "Activity type cannot exceed 50 characters")
        @Schema(description = "Type of activity performed", 
                example = "CHART_GENERATED",
                allowableValues = {"LOGIN", "LOGOUT", "CHART_GENERATED", "PROFILE_UPDATED", "CONSULTATION_BOOKED", "REPORT_DOWNLOADED", "SETTINGS_CHANGED"})
        private String activityType;
        
        @NotBlank(message = "Activity description cannot be blank")
        @Size(max = 500, message = "Activity description cannot exceed 500 characters")
        @Schema(description = "Detailed description of the activity", example = "Generated Vedic birth chart with Lahiri Ayanamsa")
        private String description;
        
        @JsonFormat(pattern = "yyyy-MM-dd'T'HH:mm:ss")
        @Schema(description = "When the activity occurred", example = "2024-01-15T14:30:00")
        private LocalDateTime timestamp;
        
        @Schema(description = "IP address from which activity originated", example = "192.168.1.100")
        private String ipAddress;
        
        @Size(max = 20, message = "Device type cannot exceed 20 characters")
        @Schema(description = "Device type used for activity", 
                example = "DESKTOP",
                allowableValues = {"DESKTOP", "MOBILE", "TABLET", "UNKNOWN"})
        private String deviceType;
        
        @Schema(description = "Additional activity metadata and context")
        private Map<String, Object> metadata;
        
        @Size(max = 20, message = "Status cannot exceed 20 characters")
        @Schema(description = "Activity completion status", 
                example = "SUCCESS",
                allowableValues = {"SUCCESS", "FAILED", "PENDING", "CANCELLED"})
        private String status;
        
        @Schema(description = "Duration of activity in milliseconds", example = "1500")
        private Long durationMs;
        
        @Schema(description = "User agent string from request")
        private String userAgent;
        
        @Schema(description = "Session identifier", example = "sess_abc123")
        private String sessionId;
        
        @Schema(description = "Activity category for grouping", example = "ASTROLOGY")
        private String category;
        
        @Schema(description = "Priority level of the activity", example = "NORMAL")
        private String priority;
        
        @Schema(description = "Geographic location of activity")
        private String location;
        
        @Schema(description = "Error details if activity failed")
        private String errorDetails;
        
        // Constructors
        public ActivityRecord() {}
        
        public ActivityRecord(String activityType, String description, LocalDateTime timestamp) {
            this.activityType = activityType;
            this.description = description;
            this.timestamp = timestamp;
            this.status = "SUCCESS";
        }
        
        public ActivityRecord(String activityType, String description, LocalDateTime timestamp, String status) {
            this(activityType, description, timestamp);
            this.status = status;
        }
        
        // Enhanced utility methods
        @JsonProperty("formattedTimestamp")
        public String getFormattedTimestamp() {
            return timestamp != null ? timestamp.format(DateTimeFormatter.ofPattern("MMM dd, yyyy HH:mm:ss")) : null;
        }
        
        @JsonProperty("isRecentActivity")
        public boolean isRecentActivity() {
            if (timestamp == null) return false;
            return timestamp.isAfter(LocalDateTime.now().minusHours(24));
        }
        
        @JsonProperty("activityAge")
        public String getActivityAge() {
            if (timestamp == null) return "Unknown";
            
            long minutesAgo = java.time.Duration.between(timestamp, LocalDateTime.now()).toMinutes();
            
            if (minutesAgo < 1) return "Just now";
            if (minutesAgo < 60) return minutesAgo + " minutes ago";
            if (minutesAgo < 1440) return (minutesAgo / 60) + " hours ago";
            return (minutesAgo / 1440) + " days ago";
        }
        
        @JsonProperty("isSuccessful")
        public boolean isSuccessful() {
            return "SUCCESS".equals(status);
        }
        
        // Getters and setters
        public Long getId() { return id; }
        public void setId(Long id) { this.id = id; }
        
        public String getActivityType() { return activityType; }
        public void setActivityType(String activityType) { this.activityType = activityType; }
        
        public String getDescription() { return description; }
        public void setDescription(String description) { this.description = description; }
        
        public LocalDateTime getTimestamp() { return timestamp; }
        public void setTimestamp(LocalDateTime timestamp) { this.timestamp = timestamp; }
        
        public String getIpAddress() { return ipAddress; }
        public void setIpAddress(String ipAddress) { this.ipAddress = ipAddress; }
        
        public String getDeviceType() { return deviceType; }
        public void setDeviceType(String deviceType) { this.deviceType = deviceType; }
        
        public Map<String, Object> getMetadata() { return metadata; }
        public void setMetadata(Map<String, Object> metadata) { this.metadata = metadata; }
        
        public String getStatus() { return status; }
        public void setStatus(String status) { this.status = status; }
        
        public Long getDurationMs() { return durationMs; }
        public void setDurationMs(Long durationMs) { this.durationMs = durationMs; }
        
        public String getUserAgent() { return userAgent; }
        public void setUserAgent(String userAgent) { this.userAgent = userAgent; }
        
        public String getSessionId() { return sessionId; }
        public void setSessionId(String sessionId) { this.sessionId = sessionId; }
        
        public String getCategory() { return category; }
        public void setCategory(String category) { this.category = category; }
        
        public String getPriority() { return priority; }
        public void setPriority(String priority) { this.priority = priority; }
        
        public String getLocation() { return location; }
        public void setLocation(String location) { this.location = location; }
        
        public String getErrorDetails() { return errorDetails; }
        public void setErrorDetails(String errorDetails) { this.errorDetails = errorDetails; }
    }
    
    @Schema(description = "Comprehensive activity summary and analytics")
    public static class ActivitySummary {
        @Schema(description = "Most frequently performed activity type")
        private String mostCommonActivity;
        
        @Schema(description = "Day of week with highest activity", example = "Monday")
        private String mostActiveDay;
        
        @Min(value = 0, message = "Most active hour must be between 0-23")
        @Max(value = 23, message = "Most active hour must be between 0-23")
        @Schema(description = "Hour of day with most activity (0-23)", example = "14")
        private Integer mostActiveHour;
        
        @DecimalMin(value = "0.0", message = "Average activities per day cannot be negative")
        @Schema(description = "Average number of activities per day", example = "5.2")
        private Double averageActivitiesPerDay;
        
        @Min(value = 0, message = "Total logins cannot be negative")
        @Schema(description = "Total login sessions in period", example = "42")
        private Integer totalLogins;
        
        @Min(value = 0, message = "Total charts cannot be negative")
        @Schema(description = "Total charts generated in period", example = "15")
        private Integer totalCharts;
        
        @Schema(description = "Success rate percentage", example = "98.5")
        private Double successRate;
        
        @Schema(description = "Average session duration in minutes", example = "23.4")
        private Double averageSessionDuration;
        
        @Schema(description = "Peak activity periods")
        private List<String> peakHours;
        
        @Schema(description = "Most used device type", example = "DESKTOP")
        private String primaryDeviceType;
        
        @Schema(description = "Activity trend direction", example = "INCREASING")
        private String trendDirection;
        
        @Schema(description = "Engagement level assessment", example = "HIGH")
        private String engagementLevel;
        
        // Constructors
        public ActivitySummary() {}
        
        // Utility methods
        @JsonProperty("isHighEngagement")
        public boolean isHighEngagement() {
            return "HIGH".equals(engagementLevel) || "VERY_HIGH".equals(engagementLevel);
        }
        
        @JsonProperty("performanceGrade")
        public String getPerformanceGrade() {
            if (successRate == null) return "Unknown";
            if (successRate >= 95) return "Excellent";
            if (successRate >= 85) return "Good";
            if (successRate >= 70) return "Fair";
            return "Needs Improvement";
        }
        
        // Getters and setters
        public String getMostCommonActivity() { return mostCommonActivity; }
        public void setMostCommonActivity(String mostCommonActivity) { this.mostCommonActivity = mostCommonActivity; }
        
        public String getMostActiveDay() { return mostActiveDay; }
        public void setMostActiveDay(String mostActiveDay) { this.mostActiveDay = mostActiveDay; }
        
        public Integer getMostActiveHour() { return mostActiveHour; }
        public void setMostActiveHour(Integer mostActiveHour) { this.mostActiveHour = mostActiveHour; }
        
        public Double getAverageActivitiesPerDay() { return averageActivitiesPerDay; }
        public void setAverageActivitiesPerDay(Double averageActivitiesPerDay) { this.averageActivitiesPerDay = averageActivitiesPerDay; }
        
        public Integer getTotalLogins() { return totalLogins; }
        public void setTotalLogins(Integer totalLogins) { this.totalLogins = totalLogins; }
        
        public Integer getTotalCharts() { return totalCharts; }
        public void setTotalCharts(Integer totalCharts) { this.totalCharts = totalCharts; }
        
        public Double getSuccessRate() { return successRate; }
        public void setSuccessRate(Double successRate) { this.successRate = successRate; }
        
        public Double getAverageSessionDuration() { return averageSessionDuration; }
        public void setAverageSessionDuration(Double averageSessionDuration) { this.averageSessionDuration = averageSessionDuration; }
        
        public List<String> getPeakHours() { return peakHours; }
        public void setPeakHours(List<String> peakHours) { this.peakHours = peakHours; }
        
        public String getPrimaryDeviceType() { return primaryDeviceType; }
        public void setPrimaryDeviceType(String primaryDeviceType) { this.primaryDeviceType = primaryDeviceType; }
        
        public String getTrendDirection() { return trendDirection; }
        public void setTrendDirection(String trendDirection) { this.trendDirection = trendDirection; }
        
        public String getEngagementLevel() { return engagementLevel; }
        public void setEngagementLevel(String engagementLevel) { this.engagementLevel = engagementLevel; }
    }
    
    @Schema(description = "Activity filtering criteria")
    public static class ActivityFilter {
        @Schema(description = "Date range start")
        @JsonFormat(pattern = "yyyy-MM-dd'T'HH:mm:ss")
        private LocalDateTime startDate;
        
        @Schema(description = "Date range end")
        @JsonFormat(pattern = "yyyy-MM-dd'T'HH:mm:ss")
        private LocalDateTime endDate;
        
        @Schema(description = "Activity types to include")
        private List<String> activityTypes;
        
        @Schema(description = "Status filters applied")
        private List<String> statuses;
        
        @Schema(description = "Device type filters")
        private List<String> deviceTypes;
        
        // Constructors, getters, and setters
        public ActivityFilter() {}
        
        public LocalDateTime getStartDate() { return startDate; }
        public void setStartDate(LocalDateTime startDate) { this.startDate = startDate; }
        
        public LocalDateTime getEndDate() { return endDate; }
        public void setEndDate(LocalDateTime endDate) { this.endDate = endDate; }
        
        public List<String> getActivityTypes() { return activityTypes; }
        public void setActivityTypes(List<String> activityTypes) { this.activityTypes = activityTypes; }
        
        public List<String> getStatuses() { return statuses; }
        public void setStatuses(List<String> statuses) { this.statuses = statuses; }
        
        public List<String> getDeviceTypes() { return deviceTypes; }
        public void setDeviceTypes(List<String> deviceTypes) { this.deviceTypes = deviceTypes; }
    }
    
    @Schema(description = "Activity trends and patterns analysis")
    public static class ActivityTrends {
        @Schema(description = "Weekly activity comparison")
        private Map<String, Integer> weeklyComparison;
        
        @Schema(description = "Growth rate percentage", example = "12.5")
        private Double growthRate;
        
        @Schema(description = "Seasonal patterns detected")
        private List<String> seasonalPatterns;
        
        @Schema(description = "Predicted next week activity", example = "28")
        private Integer predictedActivity;
        
        // Constructors, getters, and setters
        public ActivityTrends() {}
        
        public Map<String, Integer> getWeeklyComparison() { return weeklyComparison; }
        public void setWeeklyComparison(Map<String, Integer> weeklyComparison) { this.weeklyComparison = weeklyComparison; }
        
        public Double getGrowthRate() { return growthRate; }
        public void setGrowthRate(Double growthRate) { this.growthRate = growthRate; }
        
        public List<String> getSeasonalPatterns() { return seasonalPatterns; }
        public void setSeasonalPatterns(List<String> seasonalPatterns) { this.seasonalPatterns = seasonalPatterns; }
        
        public Integer getPredictedActivity() { return predictedActivity; }
        public void setPredictedActivity(Integer predictedActivity) { this.predictedActivity = predictedActivity; }
    }
    
    @Schema(description = "Data quality and reliability metrics")
    public static class DataQuality {
        @Schema(description = "Data completeness percentage", example = "95.2")
        private Double completeness;
        
        @Schema(description = "Data accuracy score", example = "98.7")
        private Double accuracy;
        
        @Schema(description = "Number of data gaps detected", example = "2")
        private Integer dataGaps;
        
        @Schema(description = "Last validation timestamp")
        @JsonFormat(pattern = "yyyy-MM-dd'T'HH:mm:ss")
        private LocalDateTime lastValidated;
        
        // Constructors, getters, and setters
        public DataQuality() {}
        
        public Double getCompleteness() { return completeness; }
        public void setCompleteness(Double completeness) { this.completeness = completeness; }
        
        public Double getAccuracy() { return accuracy; }
        public void setAccuracy(Double accuracy) { this.accuracy = accuracy; }
        
        public Integer getDataGaps() { return dataGaps; }
        public void setDataGaps(Integer dataGaps) { this.dataGaps = dataGaps; }
        
        public LocalDateTime getLastValidated() { return lastValidated; }
        public void setLastValidated(LocalDateTime lastValidated) { this.lastValidated = lastValidated; }
    }
    
    // ================ CONSTRUCTORS ================
    
    public UserActivityResponse() {
        this.retrievedAt = LocalDateTime.now();
        this.activityCategorization = new HashMap<>();
        this.timeDistribution = new HashMap<>();
        this.deviceAnalytics = new HashMap<>();
        this.geographicDistribution = new HashMap<>();
        this.recentActivities = new ArrayList<>();
        this.activities = new ArrayList<>();
        
        // Initialize user-related fields with defaults
        this.totalLogins = 0;
        this.loginStreak = 0;
        this.chartsGenerated = 0;
        this.activityCount = 0;
        this.userStatus = "ACTIVE";
        this.subscriptionType = "FREE";
    }
    
    public UserActivityResponse(List<ActivityRecord> activities, int currentPage, int pageSize, int totalItems) {
        this();
        this.activities = activities != null ? activities : new ArrayList<>();
        this.currentPage = Math.max(0, currentPage);
        this.pageSize = Math.max(1, Math.min(100, pageSize));
        this.totalActivities = Math.max(0, totalItems);
        this.totalPages = pageSize > 0 ? (int) Math.ceil((double) totalItems / pageSize) : 0;
    }
    
    // ================ ALL GETTERS AND SETTERS ================
    
    // Pagination getters/setters
    public Integer getTotalActivities() { return totalActivities; }
    public void setTotalActivities(Integer totalActivities) { 
        this.totalActivities = totalActivities != null && totalActivities >= 0 ? totalActivities : 0;
    }
    
    public Integer getCurrentPage() { return currentPage; }
    public void setCurrentPage(Integer currentPage) { 
        this.currentPage = currentPage != null && currentPage >= 0 ? currentPage : 0;
    }
    
    public Integer getPageSize() { return pageSize; }
    public void setPageSize(Integer pageSize) { 
        if (pageSize != null) {
            this.pageSize = Math.max(1, Math.min(100, pageSize));
        }
    }
    
    public Integer getTotalPages() { return totalPages; }
    public void setTotalPages(Integer totalPages) { 
        this.totalPages = totalPages != null && totalPages >= 0 ? totalPages : 0;
    }
    
    // Activity data getters/setters
    public List<ActivityRecord> getActivities() { return activities; }
    public void setActivities(List<ActivityRecord> activities) { 
        this.activities = activities != null ? activities : new ArrayList<>();
    }
    
    public LocalDateTime getRetrievedAt() { return retrievedAt; }
    public void setRetrievedAt(LocalDateTime retrievedAt) { this.retrievedAt = retrievedAt; }
    
    public ActivitySummary getSummary() { return summary; }
    public void setSummary(ActivitySummary summary) { this.summary = summary; }
    
    public List<ActivityRecord> getRecentActivities() { return recentActivities; }
    public void setRecentActivities(List<ActivityRecord> recentActivities) { 
        this.recentActivities = recentActivities != null ? recentActivities : new ArrayList<>();
        this.activityCount = this.recentActivities.size();
    }
    
    public Integer getActivityCount() { return activityCount; }
    public void setActivityCount(Integer activityCount) { 
        this.activityCount = activityCount != null && activityCount >= 0 ? activityCount : 0;
    }
    
    // User context getters/setters
    public String getUsername() { return username; }
    public void setUsername(String username) { 
        this.username = username != null ? username.trim() : null;
    }
    
    public Integer getTotalLogins() { return totalLogins; }
    public void setTotalLogins(Integer totalLogins) { 
        this.totalLogins = totalLogins != null && totalLogins >= 0 ? totalLogins : 0;
    }
    
    public Integer getLoginStreak() { return loginStreak; }
    public void setLoginStreak(Integer loginStreak) { 
        this.loginStreak = loginStreak != null && loginStreak >= 0 ? loginStreak : 0;
    }
    
    public LocalDateTime getLastLogin() { return lastLogin; }
    public void setLastLogin(LocalDateTime lastLogin) { 
        this.lastLogin = lastLogin;
    }
    
    public LocalDateTime getLastActiveDate() { return lastActiveDate; }
    public void setLastActiveDate(LocalDateTime lastActiveDate) { 
        this.lastActiveDate = lastActiveDate;
    }
    
    public String getLastLoginIp() { return lastLoginIp; }
    public void setLastLoginIp(String lastLoginIp) { 
        this.lastLoginIp = lastLoginIp != null ? lastLoginIp.trim() : null;
    }
    
    public Integer getChartsGenerated() { return chartsGenerated; }
    public void setChartsGenerated(Integer chartsGenerated) { 
        this.chartsGenerated = chartsGenerated != null && chartsGenerated >= 0 ? chartsGenerated : 0;
    }
    
    public LocalDateTime getMemberSince() { return memberSince; }
    public void setMemberSince(LocalDateTime memberSince) { 
        this.memberSince = memberSince;
    }
    
    public String getDisplayName() { return displayName; }
    public void setDisplayName(String displayName) { 
        this.displayName = displayName != null ? displayName.trim() : null;
    }
    
    public String getEmail() { return email; }
    public void setEmail(String email) { 
        this.email = email != null ? email.trim() : null;
    }
    
    public String getUserStatus() { return userStatus; }
    public void setUserStatus(String userStatus) { 
        this.userStatus = userStatus != null ? userStatus.trim().toUpperCase() : null;
    }
    
    public String getSubscriptionType() { return subscriptionType; }
    public void setSubscriptionType(String subscriptionType) { 
        this.subscriptionType = subscriptionType != null ? subscriptionType.trim().toUpperCase() : null;
    }
    
    public String getTimezone() { return timezone; }
    public void setTimezone(String timezone) { 
        this.timezone = timezone != null ? timezone.trim() : null;
    }
    
    public String getPreferredLanguage() { return preferredLanguage; }
    public void setPreferredLanguage(String preferredLanguage) { 
        this.preferredLanguage = preferredLanguage != null ? preferredLanguage.trim().toLowerCase() : null;
    }
    
    // Enhanced analytics getters/setters
    public ActivityFilter getAppliedFilter() { return appliedFilter; }
    public void setAppliedFilter(ActivityFilter appliedFilter) { this.appliedFilter = appliedFilter; }
    
    public ActivityTrends getTrends() { return trends; }
    public void setTrends(ActivityTrends trends) { this.trends = trends; }
    
    public DataQuality getDataQuality() { return dataQuality; }
    public void setDataQuality(DataQuality dataQuality) { this.dataQuality = dataQuality; }
    
    public Map<String, Integer> getActivityCategorization() { return activityCategorization; }
    public void setActivityCategorization(Map<String, Integer> activityCategorization) { 
        this.activityCategorization = activityCategorization != null ? activityCategorization : new HashMap<>();
    }
    
    public Map<String, Integer> getTimeDistribution() { return timeDistribution; }
    public void setTimeDistribution(Map<String, Integer> timeDistribution) { 
        this.timeDistribution = timeDistribution != null ? timeDistribution : new HashMap<>();
    }
    
    public Map<String, Integer> getDeviceAnalytics() { return deviceAnalytics; }
    public void setDeviceAnalytics(Map<String, Integer> deviceAnalytics) { 
        this.deviceAnalytics = deviceAnalytics != null ? deviceAnalytics : new HashMap<>();
    }
    
    public Map<String, Integer> getGeographicDistribution() { return geographicDistribution; }
    public void setGeographicDistribution(Map<String, Integer> geographicDistribution) { 
        this.geographicDistribution = geographicDistribution != null ? geographicDistribution : new HashMap<>();
    }
    
    // ================ ENHANCED UTILITY METHODS ================
    
    @JsonProperty("hasNextPage")
    public boolean hasNextPage() {
        return currentPage != null && totalPages != null && currentPage < totalPages - 1;
    }
    
    @JsonProperty("hasPreviousPage")
    public boolean hasPreviousPage() {
        return currentPage != null && currentPage > 0;
    }
    
    @JsonProperty("isEmpty")
    public boolean isEmpty() {
        return activities == null || activities.isEmpty();
    }
    
    @JsonProperty("hasData")
    public boolean hasData() {
        return !isEmpty() && totalActivities != null && totalActivities > 0;
    }
    
    @JsonProperty("isFirstPage")
    public boolean isFirstPage() {
        return currentPage != null && currentPage == 0;
    }
    
    @JsonProperty("isLastPage")
    public boolean isLastPage() {
        return currentPage != null && totalPages != null && currentPage == totalPages - 1;
    }
    
    @JsonProperty("pageInfo")
    public Map<String, Object> getPageInfo() {
        Map<String, Object> pageInfo = new HashMap<>();
        pageInfo.put("currentPage", currentPage);
        pageInfo.put("pageSize", pageSize);
        pageInfo.put("totalPages", totalPages);
        pageInfo.put("totalActivities", totalActivities);
        pageInfo.put("hasNextPage", hasNextPage());
        pageInfo.put("hasPreviousPage", hasPreviousPage());
        pageInfo.put("isFirstPage", isFirstPage());
        pageInfo.put("isLastPage", isLastPage());
        
        if (currentPage != null && pageSize != null) {
            int startItem = currentPage * pageSize + 1;
            int endItem = Math.min((currentPage + 1) * pageSize, totalActivities != null ? totalActivities : 0);
            pageInfo.put("startItem", startItem);
            pageInfo.put("endItem", endItem);
            pageInfo.put("showingItems", String.format("Showing %d-%d of %d", startItem, endItem, totalActivities));
        }
        
        return pageInfo;
    }
    
    // User-related utility methods
    @JsonProperty("memberDuration")
    public String getMemberDuration() {
        if (memberSince == null) return "Unknown";
        
        long days = ChronoUnit.DAYS.between(memberSince, LocalDateTime.now());
        
        if (days < 1) return "New member";
        if (days < 30) return days + " days";
        if (days < 365) return (days / 30) + " months";
        return (days / 365) + " years";
    }
    
    @JsonProperty("lastActivityStatus")
    public String getLastActivityStatus() {
        LocalDateTime lastActivity = lastActiveDate != null ? lastActiveDate : lastLogin;
        if (lastActivity == null) return "No recent activity";
        
        long hoursAgo = ChronoUnit.HOURS.between(lastActivity, LocalDateTime.now());
        
        if (hoursAgo < 1) return "Active now";
        if (hoursAgo < 24) return hoursAgo + " hours ago";
        if (hoursAgo < 168) return (hoursAgo / 24) + " days ago";
        return "Inactive";
    }
    
    @JsonProperty("isPremiumUser")
    public boolean isPremiumUser() {
        return subscriptionType != null && 
               ("PREMIUM".equals(subscriptionType) || "PROFESSIONAL".equals(subscriptionType));
    }
    
    @JsonProperty("isHighlyActive")
    public boolean isHighlyActive() {
        return (loginStreak != null && loginStreak >= 7) ||
               (chartsGenerated != null && chartsGenerated >= 10);
    }
    
    @JsonProperty("userEngagementLevel")
    public String getUserEngagementLevel() {
        int score = 0;
        
        if (loginStreak != null && loginStreak >= 7) score += 25;
        if (chartsGenerated != null && chartsGenerated >= 10) score += 25;
        if (totalLogins != null && totalLogins >= 50) score += 25;
        
        LocalDateTime lastActivity = lastActiveDate != null ? lastActiveDate : lastLogin;
        if (lastActivity != null && lastActivity.isAfter(LocalDateTime.now().minusDays(1))) score += 25;
        
        if (score >= 75) return "Very High";
        if (score >= 50) return "High";
        if (score >= 25) return "Medium";
        return "Low";
    }
    
    @JsonProperty("formattedLastLogin")
    public String getFormattedLastLogin() {
        return lastLogin != null ? 
            lastLogin.format(DateTimeFormatter.ofPattern("MMM dd, yyyy 'at' HH:mm")) : "Never";
    }
    
    @JsonProperty("userSummary")
    public Map<String, Object> getUserSummary() {
        Map<String, Object> summary = new HashMap<>();
        summary.put("username", username);
        summary.put("displayName", displayName);
        summary.put("memberDuration", getMemberDuration());
        summary.put("totalLogins", totalLogins);
        summary.put("loginStreak", loginStreak);
        summary.put("chartsGenerated", chartsGenerated);
        summary.put("lastActivityStatus", getLastActivityStatus());
        summary.put("engagementLevel", getUserEngagementLevel());
        summary.put("isPremium", isPremiumUser());
        summary.put("isHighlyActive", isHighlyActive());
        return summary;
    }
    
    // Recent activities utility methods
    @JsonProperty("recentActivitiesByType")
    public Map<String, List<ActivityRecord>> getRecentActivitiesByType() {
        if (recentActivities == null) return new HashMap<>();
        
        return recentActivities.stream()
            .collect(Collectors.groupingBy(ActivityRecord::getActivityType));
    }
    
    @JsonProperty("recentSuccessfulCount")
    public int getRecentSuccessfulCount() {
        if (recentActivities == null) return 0;
        
        return (int) recentActivities.stream()
            .filter(activity -> "SUCCESS".equals(activity.getStatus()))
            .count();
    }
    
    @JsonProperty("mostRecentActivity")
    public ActivityRecord getMostRecentActivity() {
        if (recentActivities == null || recentActivities.isEmpty()) return null;
        
        return recentActivities.stream()
            .max((a1, a2) -> a1.getTimestamp().compareTo(a2.getTimestamp()))
            .orElse(null);
    }
    
    @JsonProperty("hasRecentActivity")
    public boolean hasRecentActivity() {
        return recentActivities != null && !recentActivities.isEmpty();
    }
    
    @JsonProperty("activityTypeBreakdown")
    public Map<String, Long> getActivityTypeBreakdown() {
        if (activities == null) return new HashMap<>();
        
        return activities.stream()
            .collect(Collectors.groupingBy(
                activity -> activity.getActivityType() != null ? activity.getActivityType() : "Unknown",
                Collectors.counting()
            ));
    }
    
    @JsonProperty("deviceTypeBreakdown")
    public Map<String, Long> getDeviceTypeBreakdown() {
        if (activities == null) return new HashMap<>();
        
        return activities.stream()
            .collect(Collectors.groupingBy(
                activity -> activity.getDeviceType() != null ? activity.getDeviceType() : "Unknown",
                Collectors.counting()
            ));
    }
    
    @JsonProperty("dailyActivityCount")
    public Map<String, Long> getDailyActivityCount() {
        if (activities == null) return new HashMap<>();
        
        return activities.stream()
            .filter(activity -> activity.getTimestamp() != null)
            .collect(Collectors.groupingBy(
                activity -> activity.getTimestamp().toLocalDate().toString(),
                Collectors.counting()
            ));
    }
    
    @JsonProperty("formattedRetrievedAt")
    public String getFormattedRetrievedAt() {
        return retrievedAt != null ? 
            retrievedAt.format(DateTimeFormatter.ofPattern("MMM dd, yyyy 'at' HH:mm:ss")) : null;
    }
    
    @JsonProperty("dataFreshness")
    public String getDataFreshness() {
        if (retrievedAt == null) return "Unknown";
        
        long minutesAgo = java.time.Duration.between(retrievedAt, LocalDateTime.now()).toMinutes();
        
        if (minutesAgo < 1) return "Live";
        if (minutesAgo < 5) return "Very Fresh";
        if (minutesAgo < 15) return "Fresh";
        if (minutesAgo < 60) return "Recent";
        return "Cached";
    }
    
    @JsonProperty("overallHealthScore")
    public Integer getOverallHealthScore() {
        if (summary == null) return null;
        
        int score = 50; // Base score
        
        // Success rate contribution (40 points)
        if (summary.getSuccessRate() != null) {
            score += (int) (summary.getSuccessRate() * 0.4);
        }
        
        // Engagement level contribution (30 points)
        if (summary.getEngagementLevel() != null) {
            switch (summary.getEngagementLevel()) {
                case "VERY_HIGH": score += 30; break;
                case "HIGH": score += 25; break;
                case "MEDIUM": score += 15; break;
                case "LOW": score += 5; break;
            }
        }
        
        // Activity trend contribution (20 points)
        if (summary.getTrendDirection() != null) {
            switch (summary.getTrendDirection()) {
                case "INCREASING": score += 20; break;
                case "STABLE": score += 10; break;
                case "DECREASING": score -= 10; break;
            }
        }
        
        return Math.max(0, Math.min(100, score));
    }
    
    @JsonProperty("isValidResponse")
    public boolean isValidResponse() {
        return totalActivities != null && totalActivities >= 0 &&
               currentPage != null && currentPage >= 0 &&
               pageSize != null && pageSize > 0 &&
               totalPages != null && totalPages >= 0 &&
               retrievedAt != null;
    }
    
    /**
     * Create a condensed version for API responses
     */
    public UserActivityResponse createSummaryVersion() {
        UserActivityResponse summary = new UserActivityResponse();
        summary.setTotalActivities(this.totalActivities);
        summary.setCurrentPage(this.currentPage);
        summary.setPageSize(this.pageSize);
        summary.setTotalPages(this.totalPages);
        summary.setRetrievedAt(this.retrievedAt);
        summary.setSummary(this.summary);
        summary.setUsername(this.username);
        summary.setDisplayName(this.displayName);
        
        // Include only recent activities in summary
        if (this.activities != null && !this.activities.isEmpty()) {
            List<ActivityRecord> recentActivities = this.activities.stream()
                    .limit(5)
                    .collect(Collectors.toList());
            summary.setActivities(recentActivities);
        }
        
        return summary;
    }
    
    // ================ OBJECT METHODS ================
    
    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null || getClass() != obj.getClass()) return false;
        
        UserActivityResponse that = (UserActivityResponse) obj;
        return Objects.equals(totalActivities, that.totalActivities) &&
               Objects.equals(currentPage, that.currentPage) &&
               Objects.equals(pageSize, that.pageSize) &&
               Objects.equals(activities, that.activities) &&
               Objects.equals(retrievedAt, that.retrievedAt) &&
               Objects.equals(username, that.username);
    }
    
    @Override
    public int hashCode() {
        return Objects.hash(totalActivities, currentPage, pageSize, activities, retrievedAt, username);
    }
    
    @Override
    public String toString() {
        return String.format(
            "UserActivityResponse{username='%s', totalActivities=%d, currentPage=%d, pageSize=%d, " +
            "totalPages=%d, activitiesCount=%d, recentActivitiesCount=%d, retrievedAt='%s', " +
            "hasData=%s, healthScore=%d, engagementLevel='%s'}",
            username,
            totalActivities != null ? totalActivities : 0,
            currentPage != null ? currentPage : 0,
            pageSize != null ? pageSize : 0,
            totalPages != null ? totalPages : 0,
            activities != null ? activities.size() : 0,
            recentActivities != null ? recentActivities.size() : 0,
            retrievedAt != null ? retrievedAt.format(DateTimeFormatter.ISO_LOCAL_DATE_TIME) : "null",
            hasData(),
            getOverallHealthScore() != null ? getOverallHealthScore() : 0,
            getUserEngagementLevel()
        );
    }
}
